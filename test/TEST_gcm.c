#include "gcm_sm4_256.h"
#include <stdio.h>
#include "util.h"
#include <time.h>
#define TEST 10000
#define size 64

static const u8 IV[] = {
	0xca, 0xfe, 0xba, 0xbe, 0xfa, 0xce, 0xdb, 0xad,
	0xde, 0xca, 0xf8, 0x88};
static const u8 A[] = {
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef,
	0xab, 0xad, 0xda, 0xd2};

static const u8 P4[] = {
	0xd9, 0x31, 0x32, 0x25, 0xf8, 0x84, 0x06, 0xe5,
	0xa5, 0x59, 0x09, 0xc5, 0xaf, 0xf5, 0x26, 0x9a,
	0x86, 0xa7, 0xa9, 0x53, 0x15, 0x34, 0xf7, 0xda,
	0x2e, 0x4c, 0x30, 0x3d, 0x8a, 0x31, 0x8a, 0x72,
	0x1c, 0x3c, 0x0c, 0x95, 0x95, 0x68, 0x09, 0x53,
	0x2f, 0xcf, 0x0e, 0x24, 0x49, 0xa6, 0xb5, 0x25,
	0xb1, 0x6a, 0xed, 0xf5, 0xaa, 0x0d, 0xe6, 0x57,
	0xba, 0x63, 0x7b, 0x39};
static const u8 C4[] = {
	0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24,
	0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c,
	0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0,
	0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e,
	0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c,
	0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05,
	0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97,
	0x3d, 0x58, 0xe0, 0x91};

static const u8 T4[] = {
	0x5b, 0xc9, 0x4f, 0xbc, 0x32, 0x21, 0xa5, 0xdb,
	0x94, 0xfa, 0xe9, 0x5a, 0xe7, 0x12, 0x1a, 0x47};

void init_test_data(uint8_t *buf, long int amount)
{
	uint64_t i;
	for (i = 0; i < amount - 1; i++)
	{
		buf[i] = '9';
	}
	buf[i] = 0x00;
}

int maintest()
{ // 1 for SM4-256, 2 for SM4-128
	GCM128_CONTEXT *ctx;
	char KEY[] = {0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				  0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92,
				  0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				  0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92};
	char KEY128[] = {0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
					 0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92};
	u8 T[] = {
		0x4d, 0x5c, 0x2a, 0xf3, 0x27, 0xcd, 0x64, 0xa6,
		0x2c, 0xf3, 0x5a, 0xbd, 0x2b, 0xa6, 0xfa, 0xb4};

	// SM4_256_KEY *KS = (SM4_256_KEY*)malloc(sizeof(SM4_256_KEY));
	u8 in[64] = {"12345asdfgh23456789012345678901234567890123456789012345678901234"}, out[100] = {0x00}, outde[100] = {0x00};
	u8 out_de[] = {0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92, 
				   0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92,
				   0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92, 
				   0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92, 
				   0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92, 
				   0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				   0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92};

	char cyphername[2][16] = {"SM4-256-GCM", "SM4-128-GCM"};

	ctx = (GCM128_CONTEXT *)malloc(sizeof(GCM128_CONTEXT));
	gcm128_init(ctx, KEY128);
	uint8_t buf[1048577];
	uint8_t out_buf[1048577];
	init_test_data(buf, 1048577); //测试数据固定 9999
	init_test_data(out_buf, 1048577);

	uint64_t amount;
	uint64_t starttime, endtime, ans;

	gcm128_setiv(ctx, IV, 12); //将IV放到ctx中
	gcm128_aad(ctx, A, sizeof(A)); //sizeof(A) = 20
	
	for (amount = 16; amount <= 1048576; amount *= 4)
	{
		uint64_t i = 0;
		time_t endwait = time(NULL) + 3, finish_crypt_time, start_crypt_time;
		start_crypt_time = time(NULL);
		while (time(NULL) < endwait)
		{
			i++;
			gcm128_setiv(ctx, IV, 12);
			gcm128_encrypt(ctx, buf, out_buf, amount);
		}
		finish_crypt_time = time(NULL);

		printf("doing %s for 3s on %d size blocks %lld in %.2fs\t", cyphername[0], amount, i, (double)(finish_crypt_time - start_crypt_time));
		printf("%.2fMbps\n", (double)(i * amount / 1000000));

		starttime = start_rdtsc();
		for (i = 0; i < TEST; i++)
		{
			gcm128_setiv(ctx, IV, 12);
			gcm128_encrypt(ctx, buf, out_buf, amount);
		}
		endtime = end_rdtsc();
		ans = endtime - starttime;
		printf("cpu cycles/byte in doing %s on %d size blocks for :%llu \n", cyphername[0], amount, ans / amount / TEST);
	}
	return 0;
}

void rand_8bit(uint8_t * A, int len)
{
	srand((unsigned)time(NULL));
	if( A == NULL && len == 0 )
	{
		printf("rand input error!");
		return 0; //可以设置一个error错误
	}
	for(int i = 0 ; i < len; i++)	
	{
		A[i] = 0x00 + rand()%256;
	}	
}
int Isequal(uint8_t* a, uint8_t* b, int len)
{
	int i = 0; 
	for(i = 0; i < len; i++)
	{
		if(a[i] != b[i])
		{
			return 0;
		}
	}
	return 1;
}
int correctness_test(int num, int *s, int k) //正确性测试
{
	char KEY[] = {0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				  0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92,
				  0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
				  0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92};
	char KEY128[] = {0x5f, 0xea, 0x79, 0x3a, 0x2d, 0x6f, 0x97, 0x4d,
					 0x37, 0xe6, 0x8e, 0x0c, 0xb8, 0xff, 0x94, 0x92};
	int i = 0;
	uint8_t Plaintext[num][s[k]]; //随机生成128bit明文
	for(i = 0 ; i < num; i++)
		rand_8bit( Plaintext[i] , s[k] );
	uint8_t Ciphertext[num][s[k]], deCiphertext[num][s[k]];//密文与解密文

	GCM128_CONTEXT* ctx = (GCM128_CONTEXT*)malloc(sizeof(GCM128_CONTEXT));
	for(i = 0; i < num; i++)
	{
		gcm128_init(ctx, KEY128); //生成 轮密钥与轮哈希密钥
		gcm128_setiv(ctx, IV, 12); 
		gcm128_aad(ctx, A, sizeof(A)); //sizeof(A) = 20
		gcm128_encrypt(ctx, Plaintext[i], Ciphertext[i], s[k]);
		gcm128_setiv(ctx, IV, 12);
		gcm128_decrypt(ctx, Ciphertext[i], deCiphertext[i], s[k]);
		if(!Isequal(Plaintext[i],deCiphertext[i],s[k]))
		{
			printf("enc or dec error!!!!!!!!!");
			return 0;
		}
	}
	printf("correctness_test success!!!!!!!");
	return 1;
}

int main()
{
	// int s[4] = {16, 64, 256, 1024};
	// int num = 1024;
	// for(int i = 0; i < 4; i++)
	// {
	// 	if(correctness_test(num, s, i))
	// 		printf("----Correctness Test----\n for %d len,and for %d plaintexts passed!\n\n",s[i],num);
	// }
	maintest();
	return 0;
}